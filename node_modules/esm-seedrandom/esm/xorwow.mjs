function _prng_restore(prng, xg, opts) {
  let state = opts && opts.state;
  if (state) {
    if (typeof(state) == 'object') xg.copy(state, xg);
    prng.state = () => xg.copy(xg, {});
  }
}

function _prng_xor_core(xg, opts) {
  let prng = () => (xg.next() >>> 0) / 0x100000000;

  prng.double = () => {
    let top, bot, result;
    do {
      top = xg.next() >>> 11;
      bot = (xg.next() >>> 0) / 0x100000000;
      result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };

  prng.int32 = () => xg.next() | 0;

  prng.quick = prng;

  _prng_restore(prng, xg, opts);
  return prng;
}

// A Javascript implementaion of the "xorwow" prng algorithm by
function prng_xorwow(seed, opts) {
  let xg = new XorWowGen(seed);
  return _prng_xor_core(xg, opts);
}

class XorWowGen {
  constructor(seed) {
    if (seed == null) seed = +(new Date);

    let strseed = '';

    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.w = 0;
    this.v = 0;

    if (seed === (seed | 0)) {
      // Integer seed.
      this.x = seed;
    } else {
      // String seed.
      strseed += seed;
    }

    // Mix in string seed, then discard an initial batch of 64 values.
    for (let k = 0; k < strseed.length + 64; k++) {
      this.x ^= strseed.charCodeAt(k) | 0;
      if (k == strseed.length) {
        this.d = this.x << 10 ^ this.x >>> 4;
      }
      this.next();
    }
  }

  next() {
    let {x,y,z,w,v,d} = this;
    let t = (x ^ (x >>> 2));
    this.x = y;
    this.y = z;
    this.z = w;
    this.w = v;
    return (this.d = (d + 362437 | 0)) +
       (this.v = (v ^ (v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  copy(f, t) {
    t.x = f.x;
    t.y = f.y;
    t.z = f.z;
    t.w = f.w;
    t.v = f.v;
    t.d = f.d;
    return t;
  }
}

export default prng_xorwow;
export { prng_xorwow };
//# sourceMappingURL=xorwow.mjs.map
